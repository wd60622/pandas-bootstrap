{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pandas Bootstrap","text":"<p>Bootrapping with Pandas made easy.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pandas-bootstrap\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The module is very easy to use. </p> <ol> <li><code>import bootstrap</code></li> <li>define statistic function: <code>def some_func(df: pd.DataFrame | pd.Series):</code></li> <li>get bootstrapped samples: <code>df.boot.get_samples(bfunc=some_func, B=100)</code></li> </ol> <p>The return type of <code>get_samples</code> is determined by the return type of the <code>bfunc</code> function. See here for more details.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Below is a simple example of bootstrapping the mean of two columns.</p> <pre><code>import pandas as pd\n\nimport bootstrap\n\ndf = pd.DataFrame({\n    'a': [1, 2, 3, 4, 5],\n    'b': [6, 7, 8, 9, 10],\n})\n\ndef mean_of_columns(df):\n    return df.mean(numeric_only=True)\n\nsample_kwargs = dict(random_state=42)\ndf_bootstrap = df.boot.get_samples(bfunc=mean_of_columns, B=5, sample_kwargs=sample_kwargs)\n</code></pre> <p>which results in:</p> <pre><code>          a    b\nsample          \n0       3.0  8.0\n1       2.6  7.6\n2       4.0  9.0\n3       3.2  8.2\n4       3.0  8.0\n</code></pre> <p>Read more in examples here.</p>"},{"location":"bootstrap/","title":"bootstrap","text":"<p>Core bootstrapping logic which powers the <code>boot</code> extension including parallelization and return type inference.</p>"},{"location":"bootstrap/#bootstrap.bootstrap.DataFrameFunction","title":"<code>DataFrameFunction</code>","text":"<p>Process a bootstrap function that returns a DataFrame.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>class DataFrameFunction:\n    \"\"\"Process a bootstrap function that returns a DataFrame.\"\"\"\n\n    append_axis: int = 0\n\n    @staticmethod\n    def name(boot_sample, i: int):\n        boot_sample[\"sample\"] = i\n        return boot_sample\n\n    @staticmethod\n    def post_process(df: pd.DataFrame) -&gt; pd.DataFrame:\n        return df.set_index(\"sample\", append=True).sort_index()\n</code></pre>"},{"location":"bootstrap/#bootstrap.bootstrap.SeriesFunction","title":"<code>SeriesFunction</code>","text":"<p>Process a bootstrap function that returns a Series.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>class SeriesFunction:\n    \"\"\"Process a bootstrap function that returns a Series.\"\"\"\n\n    append_axis: int = 1\n\n    @staticmethod\n    def name(boot_sample: pd.Series, i: int):\n        boot_sample.name = i\n        return boot_sample\n\n    @staticmethod\n    def post_process(s: pd.DataFrame) -&gt; pd.DataFrame:\n        s = s.T\n        s.index.name = \"sample\"\n        return s\n</code></pre>"},{"location":"bootstrap/#bootstrap.bootstrap.UnsupportedReturnType","title":"<code>UnsupportedReturnType</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a bootstrap function returns an unsupported type.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>class UnsupportedReturnType(Exception):\n    \"\"\"Raised when a bootstrap function returns an unsupported type.\"\"\"\n</code></pre>"},{"location":"bootstrap/#bootstrap.bootstrap.bootstrap","title":"<code>bootstrap(bfunc_input, bfunc, B=100, sample_kwargs=None, parallel=None, **kwargs)</code>","text":"<p>Core bootstrap function.</p> <p>Parameters:</p> Name Type Description Default <code>bfunc_input</code> <code>BFUNC_INPUT</code> <p>Input to bootstrap function.</p> required <code>bfunc</code> <code>BFUNC</code> <p>Bootstrap function.</p> required <code>B</code> <code>int</code> <p>Number of bootstrap samples.</p> <code>100</code> <code>sample_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Keyword arguments to pass to the sampling function.</p> <code>None</code> <code>parallel</code> <code>Optional[Parallel]</code> <p>Parallelization object.</p> <code>None</code> <code>**kwargs</code> <p>Keyword arguments to pass to the bootstrap function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[DataFrame, Series]</code> <p>Bootstrap samples in a DataFrame or Series.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If sample_kwargs contains 'replace' or 'frac' keys.</p> <code>UnsupportedReturnType</code> <p>If the bootstrap function returns an unsupported type.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>def bootstrap(\n    bfunc_input: BFUNC_INPUT,\n    bfunc: BFUNC,\n    B: int = 100,\n    sample_kwargs: Optional[Dict[str, Any]] = None,\n    parallel: Optional[Parallel] = None,\n    **kwargs,\n) -&gt; Union[pd.DataFrame, pd.Series]:\n    \"\"\"Core bootstrap function.\n\n    Args:\n        bfunc_input: Input to bootstrap function.\n        bfunc: Bootstrap function.\n        B: Number of bootstrap samples.\n        sample_kwargs: Keyword arguments to pass to the sampling function.\n        parallel: Parallelization object.\n        **kwargs: Keyword arguments to pass to the bootstrap function.\n\n    Returns:\n        Bootstrap samples in a DataFrame or Series.\n\n    Raises:\n        ValueError: If sample_kwargs contains 'replace' or 'frac' keys.\n        UnsupportedReturnType: If the bootstrap function returns an unsupported type.\n\n    \"\"\"\n    sample_kwargs = {} if sample_kwargs is None else copy(sample_kwargs)\n\n    if \"replace\" in sample_kwargs or \"frac\" in sample_kwargs:\n        raise ValueError(\"sample_kwargs cannot contain 'replace' or 'frac' keys.\")\n\n    if \"random_state\" in sample_kwargs and isinstance(\n        sample_kwargs[\"random_state\"], int\n    ):\n        sample_kwargs[\"random_state\"] = np.random.default_rng(\n            sample_kwargs[\"random_state\"]\n        )\n\n    sample_kwargs[\"replace\"] = True\n    sample_kwargs[\"frac\"] = 1\n\n    return_type = get_return_type(bfunc)\n    if return_type in {Signature.empty, float, int}:\n        bfunc, return_type = infer_return_type(bfunc_input, bfunc, **kwargs)\n\n    bfunc_processor = get_bfunc_processor(return_type)\n\n    loop_func = loop if parallel is None else create_parallel_loop(parallel)\n    inner_loop_func = create_inner_loop_func(\n        bfunc, bfunc_input, bfunc_processor, sample_kwargs, **kwargs\n    )\n    samples = loop_func(inner_loop_func=inner_loop_func, B=B)\n\n    return (\n        pd.concat(samples, axis=bfunc_processor.append_axis)\n        .pipe(bfunc_processor.post_process)\n        .squeeze()\n    )\n</code></pre>"},{"location":"bootstrap/#bootstrap.bootstrap.get_bfunc_processor","title":"<code>get_bfunc_processor(return_type)</code>","text":"<p>Get the appropriate bootstrap function processor.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>def get_bfunc_processor(return_type: type) -&gt; Union[DataFrameFunction, SeriesFunction]:\n    \"\"\"Get the appropriate bootstrap function processor.\"\"\"\n    if return_type == pd.DataFrame:\n        return DataFrameFunction()\n    elif return_type == pd.Series:\n        return SeriesFunction()\n    else:\n        raise UnsupportedReturnType(\n            f\"Bootstrap function must return a DataFrame or Series, not {return_type}. Consider wrapping return in pd.Series\"\n        )\n</code></pre>"},{"location":"bootstrap/#bootstrap.bootstrap.get_return_type","title":"<code>get_return_type(bfunc)</code>","text":"<p>Get the return type of a bootstrap function.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>def get_return_type(bfunc: BFUNC) -&gt; type:\n    \"\"\"Get the return type of a bootstrap function.\"\"\"\n    sig = signature(bfunc)\n    return sig.return_annotation\n</code></pre>"},{"location":"bootstrap/#bootstrap.bootstrap.infer_return_type","title":"<code>infer_return_type(df, bfunc, **kwargs)</code>","text":"<p>Infer the return type of a bootstrap function.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>BFUNC_INPUT</code> <p>The DataFrame to bootstrap.</p> required <code>bfunc</code> <code>BFUNC</code> <p>The bootstrap function.</p> required <code>**kwargs</code> <p>Keyword arguments to pass to the bootstrap function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[BFUNC, type]</code> <p>A tuple of the bootstrap function and its return type.</p> <p>Raises:</p> Type Description <code>UnsupportedReturnType</code> <p>If the bootstrap function returns an unsupported type.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>def infer_return_type(df: BFUNC_INPUT, bfunc: BFUNC, **kwargs) -&gt; Tuple[BFUNC, type]:\n    \"\"\"Infer the return type of a bootstrap function.\n\n    Args:\n        df: The DataFrame to bootstrap.\n        bfunc: The bootstrap function.\n        **kwargs: Keyword arguments to pass to the bootstrap function.\n\n    Returns:\n        A tuple of the bootstrap function and its return type.\n\n    Raises:\n        UnsupportedReturnType: If the bootstrap function returns an unsupported type.\n\n    \"\"\"\n    df_result = bfunc(df, **kwargs)\n\n    return_type = type(df_result)\n\n    not_needed_to_infer_types = {pd.DataFrame, pd.Series}\n    supported_numpy_types = {np.float32, np.float64, np.int32, np.int64}\n    need_to_infer_types = {float, int}.union(supported_numpy_types)\n\n    all_supported_types = not_needed_to_infer_types.union(need_to_infer_types)\n    if return_type not in all_supported_types:\n        raise UnsupportedReturnType(\n            f\"Bootstrap function must return a DataFrame, Series, float, or int, not {return_type}\"\n        )\n\n    if return_type in need_to_infer_types:\n\n        def wrapped_bfunc(df: BFUNC_INPUT, **kwargs) -&gt; pd.Series:\n            return pd.Series({\"stat\": bfunc(df, **kwargs)})\n\n        return_type = pd.Series\n        return wrapped_bfunc, return_type\n\n    return bfunc, return_type\n</code></pre>"},{"location":"extensions/","title":"extensions","text":"<p>Extensions for pandas DataFrames and Series. Access with the <code>boot</code> attribute of a DataFrame or Series.</p> <p>Available after importing the package:</p> <pre><code>import bootstrap\n\ndf = pd.DataFrame(...)\ndf.boot.get_samples(...)\n\nser = pd.Series(...)\nser.boot.get_samples(...)\n</code></pre>"},{"location":"extensions/#bootstrap.extensions.AccessorMixin","title":"<code>AccessorMixin</code>","text":"<p>Common functionality for DataFrame and Series accessors.</p> Source code in <code>bootstrap/extensions.py</code> <pre><code>class AccessorMixin:\n    \"\"\"Common functionality for DataFrame and Series accessors.\"\"\"\n    def __init__(self, obj):\n        self._obj = obj\n\n    def get_samples(\n        self,\n        bfunc: BFUNC,\n        B: int = 100,\n        sample_kwargs: Dict[str, Any] = None,\n        parallel: Optional[Parallel] = None,\n        **kwargs\n    ) -&gt; Union[pd.Series, pd.DataFrame]:\n        \"\"\"Get bootstrap samples of the object.\n\n        Args:\n            bfunc: Bootstrap function.\n            B: Number of bootstrap samples.\n            sample_kwargs: Keyword arguments to pass to the sample method of the object.\n            parallel: Joblib Parallel object.\n            kwargs: Keyword arguments to pass to the bootstrap function.\n\n        Returns:\n            Bootstrap samples in a Series or DataFrame. Depends on the return type of the bootstrap function.\n\n        \"\"\"\n        return bootstrap(\n            self._obj,\n            bfunc=bfunc,\n            B=B,\n            sample_kwargs=sample_kwargs,\n            parallel=parallel,\n            **kwargs\n        )\n</code></pre>"},{"location":"extensions/#bootstrap.extensions.AccessorMixin.get_samples","title":"<code>get_samples(bfunc, B=100, sample_kwargs=None, parallel=None, **kwargs)</code>","text":"<p>Get bootstrap samples of the object.</p> <p>Parameters:</p> Name Type Description Default <code>bfunc</code> <code>BFUNC</code> <p>Bootstrap function.</p> required <code>B</code> <code>int</code> <p>Number of bootstrap samples.</p> <code>100</code> <code>sample_kwargs</code> <code>Dict[str, Any]</code> <p>Keyword arguments to pass to the sample method of the object.</p> <code>None</code> <code>parallel</code> <code>Optional[Parallel]</code> <p>Joblib Parallel object.</p> <code>None</code> <code>kwargs</code> <p>Keyword arguments to pass to the bootstrap function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[Series, DataFrame]</code> <p>Bootstrap samples in a Series or DataFrame. Depends on the return type of the bootstrap function.</p> Source code in <code>bootstrap/extensions.py</code> <pre><code>def get_samples(\n    self,\n    bfunc: BFUNC,\n    B: int = 100,\n    sample_kwargs: Dict[str, Any] = None,\n    parallel: Optional[Parallel] = None,\n    **kwargs\n) -&gt; Union[pd.Series, pd.DataFrame]:\n    \"\"\"Get bootstrap samples of the object.\n\n    Args:\n        bfunc: Bootstrap function.\n        B: Number of bootstrap samples.\n        sample_kwargs: Keyword arguments to pass to the sample method of the object.\n        parallel: Joblib Parallel object.\n        kwargs: Keyword arguments to pass to the bootstrap function.\n\n    Returns:\n        Bootstrap samples in a Series or DataFrame. Depends on the return type of the bootstrap function.\n\n    \"\"\"\n    return bootstrap(\n        self._obj,\n        bfunc=bfunc,\n        B=B,\n        sample_kwargs=sample_kwargs,\n        parallel=parallel,\n        **kwargs\n    )\n</code></pre>"},{"location":"extensions/#bootstrap.extensions.DataFrameBootstrapAccessor","title":"<code>DataFrameBootstrapAccessor</code>","text":"<p>             Bases: <code>AccessorMixin</code></p> <p>Bootstrap accessor for pandas DataFrames.</p> <p>Examples:</p> <p>Bootstrap the mean of each column in a DataFrame.</p> <pre><code>import pandas as pd\nimport bootstrap\n\ndf = pd.DataFrame({\n    'a': [1, 2, 3, 4, 5],\n    'b': [6, 7, 8, 9, 10],\n})\n\ndef mean_of_columns(df):\n    return df.mean(numeric_only=True)\n\ndf_bootstrap: pd.DataFrame = df.boot.get_samples(bfunc=mean_of_columns, B=100)\n</code></pre> Source code in <code>bootstrap/extensions.py</code> <pre><code>@pd.api.extensions.register_dataframe_accessor(\"boot\")\nclass DataFrameBootstrapAccessor(AccessorMixin):\n    \"\"\"Bootstrap accessor for pandas DataFrames.\n\n    Examples:\n        Bootstrap the mean of each column in a DataFrame.\n\n        ```python\n        import pandas as pd\n        import bootstrap\n\n        df = pd.DataFrame({\n            'a': [1, 2, 3, 4, 5],\n            'b': [6, 7, 8, 9, 10],\n        })\n\n        def mean_of_columns(df):\n            return df.mean(numeric_only=True)\n\n        df_bootstrap: pd.DataFrame = df.boot.get_samples(bfunc=mean_of_columns, B=100)\n        ```\n\n    \"\"\"\n</code></pre>"},{"location":"extensions/#bootstrap.extensions.SeriesBootstrapAccessor","title":"<code>SeriesBootstrapAccessor</code>","text":"<p>             Bases: <code>AccessorMixin</code></p> <p>Bootstrap accessor for pandas Series.</p> <p>Examples:</p> <p>Bootstrap the mean of a Series.</p> <pre><code>import pandas as pd\nimport bootstrap\n\nser = pd.Series([1, 2, 3, 4, 5])\n\ndef mean_of_series(ser):\n    return ser.mean()\n\nser_bootstrap: pd.Series = ser.boot.get_samples(bfunc=mean_of_series, B=100)\n</code></pre> Source code in <code>bootstrap/extensions.py</code> <pre><code>@pd.api.extensions.register_series_accessor(\"boot\")\nclass SeriesBootstrapAccessor(AccessorMixin):\n    \"\"\"Bootstrap accessor for pandas Series.\n\n    Examples:\n        Bootstrap the mean of a Series.\n\n        ```python\n        import pandas as pd\n        import bootstrap\n\n        ser = pd.Series([1, 2, 3, 4, 5])\n\n        def mean_of_series(ser):\n            return ser.mean()\n\n        ser_bootstrap: pd.Series = ser.boot.get_samples(bfunc=mean_of_series, B=100)\n        ```\n\n    \"\"\"\n</code></pre>"},{"location":"examples/correlation/","title":"Correlation","text":"<pre><code>import pandas as pd\nimport numpy as np\n\nimport bootstrap\n\n# Generate some data\ndata = np.random.normal(loc=[0, 5, 10, 25], size=(100, 4))\ndf = pd.DataFrame(data, columns=[\"A\", \"B\", \"C\", \"D\"])\n\ndef correlation_with_a(df: pd.DataFrame) -&gt; pd.Series:\n    \"\"\"Correlation between column A and others\"\"\"\n    return df.corr().loc[\"A\", \"B\":]\n\ndf_bootstrap = df.boot.get_samples(bfunc=correlation_with_a, B=1000)\n</code></pre>"},{"location":"examples/linear-regression/","title":"Linear Regression Confidence Intervals","text":"<pre><code>import pandas as pd\nimport numpy as np\n\nfrom sklearn.linear_model import LinearRegression \n\nimport bootstrap\n\nN_POINTS = 50\n\nSLOPE = 3\nINTERCEPT = 2\nSIGMA = 5\n\ndf = pd.DataFrame({\n    \"x\": np.random.uniform(0, 3, size=N_POINTS)\n})\ndf[\"y\"] = (\n    INTERCEPT \n    + SLOPE * df[\"x\"] \n    # Noise\n    + np.random.normal(loc=0, scale=SIGMA, size=N_POINTS)\n)\n\ndef bfunc(df: pd.DataFrame, model: LinearRegression) -&gt; pd.Series: \n    model.fit(df[[\"x\"]], df[\"y\"])\n\n    return pd.Series({\n        \"intercept\": model.intercept_, \n        \"slope\": model.coef_[0]\n    })\n\nB = 5_000\nmodel = LinearRegression()\ndf_bootstrap = df.boot.get_samples(bfunc=bfunc, B=B, model=model)\n</code></pre> <p>which results in:</p> <pre><code>        intercept     slope\nsample                     \n0       -0.369922  2.985659\n1       -0.139439  3.312337\n2       -1.878551  3.981249\n3       -0.080539  2.888800\n4       -0.679095  4.191550\n</code></pre> <p></p>"},{"location":"examples/parallelization/","title":"Parallelization","text":"<p>A <code>joblib.Parallel</code> instance can be passed in order to parallelize the bootstrapping process. See the joblib documentation for more information.</p> <pre><code>from joblib import Parallel \n\nparallel = Parallel(n_jobs=-1)\n\ndef some_func(df: pd.DataFrame) -&gt; pd.Series:\n    return df.mean(numeric_only=True)\n\ndf_samples = df.boot.get_samples(bfunc=some_func, B=100, parallel=parallel)\n</code></pre> <p>Be aware that time improvement is not guaranteed. The overhead of parallelization may outweigh the benefits of parallelization. We see that a parallelized version of the function is not always faster than the non-parallelized version. However, this will depend on the machine and the configuration of the <code>joblib.Parallel</code> instance.</p> <p></p>"},{"location":"examples/return-type/","title":"Return Type","text":"<p>The return type of <code>get_samples</code> is determined by the return type of the <code>bfunc</code> function.</p> <code>bfunc</code> return type <code>get_samples</code> return type index of <code>get_samples</code> <code>float</code> or <code>int</code> <code>pd.Series</code> sample number <code>pd.Series</code> <code>pd.DataFrame</code> sample number <code>pd.DataFrame</code> <code>pd.DataFrame</code> sample number and original index"},{"location":"examples/return-type/#example","title":"Example","text":"<p>For some concrete examples, we will use the following data:</p> <pre><code>import pandas as pd\nimport numpy as np\n\nimport bootstrap\n\nn_points = 100\nrng = np.random.default_rng(0)\ndf = pd.DataFrame({\n    \"a\": rng.normal(size=n_points),\n    \"b\": rng.normal(size=n_points),\n    \"group\": rng.choice([\"A\", \"B\"], size=n_points)\n})\n</code></pre>"},{"location":"examples/return-type/#float-or-int-return-a-pdseries","title":"<code>float</code> or <code>int</code> return a <code>pd.Series</code>","text":"<pre><code>def float_return(df: pd.DataFrame, col: str) -&gt; float:\n    return df[col].mean()\n\nseries = df.boot.get_samples(bfunc=float_return, col=\"a\", B=5)\n</code></pre> <pre><code>sample\n0    0.111948\n1    0.157558\n2    0.177292\n3    0.000501\n4    0.082680\nName: stat, dtype: float64\n</code></pre>"},{"location":"examples/return-type/#pdseries-returns-a-pddataframe","title":"<code>pd.Series</code> returns a <code>pd.DataFrame</code>","text":"<pre><code>def series_return(df: pd.DataFrame) -&gt; pd.Series:\n    return df.mean(numeric_only=True)\n\ndataframe = df.boot.get_samples(bfunc=series_return, B=5)\n</code></pre> <pre><code>               a         b\nsample\n0       0.123708 -0.070613\n1      -0.011843  0.030508\n2       0.027869 -0.006668\n3       0.065575  0.043360\n4       0.089570  0.125474\n</code></pre>"},{"location":"examples/return-type/#pddataframe-returns-a-pddataframe-with-another-index","title":"<code>pd.DataFrame</code> returns a <code>pd.DataFrame</code> with another index","text":"<pre><code>def df_return(df: pd.DataFrame) -&gt; pd.DataFrame:\n    return df.groupby(\"group\").mean()\n\ndataframe_grouped = df.boot.get_samples(bfunc=df_return, B=5)\n</code></pre> <pre><code>                     a         b\ngroup sample\nA     0       0.066174 -0.125440\n      1      -0.085131 -0.079708\n      2       0.128932  0.096542\n      3       0.088746 -0.295118\n      4      -0.042594  0.063312\nB     0      -0.032779  0.035043\n      1       0.065471 -0.072222\n      2      -0.135504  0.040352\n      3       0.120614  0.202248\n      4       0.057131  0.027761\n</code></pre>"}]}