{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pandas Bootstrap","text":"<p>Bootrapping with Pandas made easy.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pandas-bootstrap\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The module is very easy to use. </p> <ol> <li><code>import bootstrap</code></li> <li>define statistic function: <code>def some_func(df: pd.DataFrame | pd.Series):</code></li> <li>get bootstrapped samples: <code>df.boot.get_samples(bfunc=some_func, B=100)</code></li> </ol> <p>Below is a simple example of bootstrapping the mean of two columns.</p> <pre><code>import pandas as pd\nimport bootstrap\ndf = pd.DataFrame({\n'a': [1, 2, 3, 4, 5],\n'b': [6, 7, 8, 9, 10],\n})\ndef mean_of_columns(df):\nreturn df.mean(numeric_only=True)\nsample_kwargs = dict(random_state=42)\ndf_bootstrap = df.boot.get_samples(bfunc=mean_of_columns, B=5, sample_kwargs=sample_kwargs)\n</code></pre> <p>which results in:</p> <pre><code>          a    b\nsample          \n0       3.0  8.0\n1       2.6  7.6\n2       4.0  9.0\n3       3.2  8.2\n4       3.0  8.0\n</code></pre> <p>Read more in examples here.</p>"},{"location":"bootstrap/","title":"bootstrap","text":""},{"location":"bootstrap/#bootstrap.bootstrap.DataFrameFunction","title":"<code>DataFrameFunction</code>","text":"<p>Process a bootstrap function that returns a DataFrame.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>class DataFrameFunction:\n\"\"\"Process a bootstrap function that returns a DataFrame.\"\"\"\nappend_axis: int = 0\n@staticmethod\ndef name(boot_sample, i: int):\nboot_sample[\"sample\"] = i\nreturn boot_sample\n@staticmethod\ndef post_process(df: pd.DataFrame) -&gt; pd.DataFrame:\nreturn df.set_index(\"sample\", append=True)\n</code></pre>"},{"location":"bootstrap/#bootstrap.bootstrap.SeriesFunction","title":"<code>SeriesFunction</code>","text":"<p>Process a bootstrap function that returns a Series.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>class SeriesFunction:\n\"\"\"Process a bootstrap function that returns a Series.\"\"\"\nappend_axis: int = 1\n@staticmethod\ndef name(boot_sample: pd.Series, i: int):\nboot_sample.name = i\nreturn boot_sample\n@staticmethod\ndef post_process(s: pd.DataFrame) -&gt; pd.DataFrame:\ns = s.T\ns.index.name = \"sample\"\nreturn s\n</code></pre>"},{"location":"bootstrap/#bootstrap.bootstrap.UnsupportedReturnType","title":"<code>UnsupportedReturnType</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when a bootstrap function returns an unsupported type.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>class UnsupportedReturnType(Exception):\n\"\"\"Raised when a bootstrap function returns an unsupported type.\"\"\"\n</code></pre>"},{"location":"bootstrap/#bootstrap.bootstrap.bootstrap","title":"<code>bootstrap(bfunc_input, bfunc, B=100, sample_kwargs=None, **kwargs)</code>","text":"<p>Core bootstrap function.</p> <p>Parameters:</p> Name Type Description Default <code>bfunc_input</code> <code>BFUNC_INPUT</code> <p>Input to bootstrap function.</p> required <code>bfunc</code> <code>BFUNC</code> <p>Bootstrap function.</p> required <code>B</code> <code>int</code> <p>Number of bootstrap samples.</p> <code>100</code> <code>sample_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Keyword arguments to pass to the sampling function.</p> <code>None</code> <code>**kwargs</code> <p>Keyword arguments to pass to the bootstrap function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[pd.DataFrame, pd.Series]</code> <p>Bootstrap samples in a DataFrame or Series.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If sample_kwargs contains 'replace' or 'frac' keys.</p> <code>UnsupportedReturnType</code> <p>If the bootstrap function returns an unsupported type.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>def bootstrap(\nbfunc_input: BFUNC_INPUT,\nbfunc: BFUNC,\nB: int = 100,\nsample_kwargs: Optional[Dict[str, Any]] = None,\n**kwargs,\n) -&gt; Union[pd.DataFrame, pd.Series]:\n\"\"\"Core bootstrap function.\n    Args: \n        bfunc_input: Input to bootstrap function.\n        bfunc: Bootstrap function.\n        B: Number of bootstrap samples.\n        sample_kwargs: Keyword arguments to pass to the sampling function.\n        **kwargs: Keyword arguments to pass to the bootstrap function.\n    Returns:\n        Bootstrap samples in a DataFrame or Series.\n    Raises:\n        ValueError: If sample_kwargs contains 'replace' or 'frac' keys.\n        UnsupportedReturnType: If the bootstrap function returns an unsupported type.\n    \"\"\"\nif sample_kwargs is None:\nsample_kwargs = {}\nif \"replace\" in sample_kwargs or \"frac\" in sample_kwargs:\nraise ValueError(\"sample_kwargs cannot contain 'replace' or 'frac' keys.\")\nif \"random_state\" in sample_kwargs and isinstance(sample_kwargs[\"random_state\"], int):\nsample_kwargs[\"random_state\"] = np.random.default_rng(sample_kwargs[\"random_state\"])\nsample_kwargs[\"replace\"] = True\nsample_kwargs[\"frac\"] = 1\nreturn_type = get_return_type(bfunc)\nif return_type in {Signature.empty, float, int}:\nbfunc, return_type = infer_return_type(bfunc_input, bfunc, **kwargs)\nbfunc_processor = get_bfunc_processor(return_type)\nsamples = []\nfor i in range(B):\nboot_sample = bfunc(bfunc_input.sample(**sample_kwargs), **kwargs)\nboot_sample = bfunc_processor.name(boot_sample, i)\nsamples.append(boot_sample)\nreturn (\npd.concat(samples, axis=bfunc_processor.append_axis)\n.pipe(bfunc_processor.post_process)\n.squeeze()\n)\n</code></pre>"},{"location":"bootstrap/#bootstrap.bootstrap.get_bfunc_processor","title":"<code>get_bfunc_processor(return_type)</code>","text":"<p>Get the appropriate bootstrap function processor.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>def get_bfunc_processor(return_type: type) -&gt; Union[DataFrameFunction, SeriesFunction]:\n\"\"\"Get the appropriate bootstrap function processor.\"\"\"\nif return_type == pd.DataFrame:\nreturn DataFrameFunction()\nelif return_type == pd.Series:\nreturn SeriesFunction()\nelse:\nraise UnsupportedReturnType(\nf\"Bootstrap function must return a DataFrame or Series, not {return_type}. Consider wrapping return in pd.Series\"\n)\n</code></pre>"},{"location":"bootstrap/#bootstrap.bootstrap.get_return_type","title":"<code>get_return_type(bfunc)</code>","text":"<p>Get the return type of a bootstrap function.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>def get_return_type(bfunc: BFUNC) -&gt; type:\n\"\"\"Get the return type of a bootstrap function.\"\"\"\nsig = signature(bfunc)\nreturn sig.return_annotation\n</code></pre>"},{"location":"bootstrap/#bootstrap.bootstrap.infer_return_type","title":"<code>infer_return_type(df, bfunc, **kwargs)</code>","text":"<p>Infer the return type of a bootstrap function.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>BFUNC_INPUT</code> <p>The DataFrame to bootstrap.</p> required <code>bfunc</code> <code>BFUNC</code> <p>The bootstrap function.</p> required <code>**kwargs</code> <p>Keyword arguments to pass to the bootstrap function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Tuple[BFUNC, type]</code> <p>A tuple of the bootstrap function and its return type.</p> <p>Raises:</p> Type Description <code>UnsupportedReturnType</code> <p>If the bootstrap function returns an unsupported type.</p> Source code in <code>bootstrap/bootstrap.py</code> <pre><code>def infer_return_type(df: BFUNC_INPUT, bfunc: BFUNC, **kwargs) -&gt; Tuple[BFUNC, type]:\n\"\"\"Infer the return type of a bootstrap function.\n    Args: \n        df: The DataFrame to bootstrap.\n        bfunc: The bootstrap function.\n        **kwargs: Keyword arguments to pass to the bootstrap function.\n    Returns:\n        A tuple of the bootstrap function and its return type.\n    Raises:\n        UnsupportedReturnType: If the bootstrap function returns an unsupported type.\n    \"\"\"\ndf_result = bfunc(df, **kwargs)\nreturn_type = type(df_result)\nnot_needed_to_infer_types = {pd.DataFrame, pd.Series}\nsupported_numpy_types = {np.float32, np.float64, np.int32, np.int64}\nneed_to_infer_types = {float, int}.union(supported_numpy_types)\nall_supported_types = not_needed_to_infer_types.union(need_to_infer_types)\nif return_type not in all_supported_types:\nraise UnsupportedReturnType(\nf\"Bootstrap function must return a DataFrame, Series, float, or int, not {return_type}\"\n)\nif return_type in need_to_infer_types:\ndef wrapped_bfunc(df: BFUNC_INPUT, **kwargs) -&gt; pd.Series:\nreturn pd.Series({\"stat\": bfunc(df, **kwargs)})\nreturn_type = pd.Series\nreturn wrapped_bfunc, return_type\nreturn bfunc, return_type\n</code></pre>"},{"location":"extensions/","title":"extensions","text":"<p>Extensions for pandas DataFrames and Series. Access with the <code>boot</code> attribute of a DataFrame or Series.</p>"},{"location":"extensions/#bootstrap.extensions.DataFrameBootstrapAccessor","title":"<code>DataFrameBootstrapAccessor</code>","text":"<p>         Bases: <code>AccessorMixin</code></p> <p>Bootstrap accessor for pandas DataFrames.</p> Example <p>Bootstrap the mean of each column in a DataFrame.</p> <pre><code>import pandas as pd\nimport bootstrap\ndf = pd.DataFrame({\n'a': [1, 2, 3, 4, 5],\n'b': [6, 7, 8, 9, 10],\n})\ndef mean_of_columns(df):\nreturn df.mean(numeric_only=True)\ndf_bootstrap: pd.DataFrame = df.boot.get_samples(bfunc=mean_of_columns, B=100)\n</code></pre> Source code in <code>bootstrap/extensions.py</code> <pre><code>@pd.api.extensions.register_dataframe_accessor(\"boot\")\nclass DataFrameBootstrapAccessor(AccessorMixin):\n\"\"\"Bootstrap accessor for pandas DataFrames.\n    Example: \n        Bootstrap the mean of each column in a DataFrame.\n        ```python \n        import pandas as pd\n        import bootstrap\n        df = pd.DataFrame({\n            'a': [1, 2, 3, 4, 5],\n            'b': [6, 7, 8, 9, 10],\n        })\n        def mean_of_columns(df):\n            return df.mean(numeric_only=True)\n        df_bootstrap: pd.DataFrame = df.boot.get_samples(bfunc=mean_of_columns, B=100)\n        ```\n    \"\"\"\n</code></pre>"},{"location":"extensions/#bootstrap.extensions.SeriesBootstrapAccessor","title":"<code>SeriesBootstrapAccessor</code>","text":"<p>         Bases: <code>AccessorMixin</code></p> <p>Bootstrap accessor for pandas Series.</p> Example <p>Bootstrap the mean of a Series.</p> <pre><code>import pandas as pd\nimport bootstrap\nser = pd.Series([1, 2, 3, 4, 5])\ndef mean_of_series(ser):\nreturn ser.mean()\nser_bootstrap: pd.Series = ser.boot.get_samples(bfunc=mean_of_series, B=100)\n</code></pre> Source code in <code>bootstrap/extensions.py</code> <pre><code>@pd.api.extensions.register_series_accessor(\"boot\")\nclass SeriesBootstrapAccessor(AccessorMixin):\n\"\"\"Bootstrap accessor for pandas Series.\n    Example: \n        Bootstrap the mean of a Series.\n        ```python\n        import pandas as pd\n        import bootstrap\n        ser = pd.Series([1, 2, 3, 4, 5])\n        def mean_of_series(ser):\n            return ser.mean()\n        ser_bootstrap: pd.Series = ser.boot.get_samples(bfunc=mean_of_series, B=100)\n        ```\n    \"\"\"\n</code></pre>"},{"location":"examples/correlation/","title":"Correlation","text":"<pre><code>import pandas as pd\nimport numpy as np\nimport bootstrap\n# Generate some data\ndata = np.random.normal(loc=[0, 5, 10, 25], size=(100, 4))\ndf = pd.DataFrame(data, columns=[\"A\", \"B\", \"C\", \"D\"])\ndef correlation_with_a(df: pd.DataFrame) -&gt; pd.Series:\n\"\"\"Correlation between column A and others\"\"\"\nreturn df.corr().loc[\"A\", \"B\":]\ndf_bootstrap = df.boot.get_samples(bfunc=correlation_with_a, B=1000)\n</code></pre>"},{"location":"examples/linear-regression/","title":"Linear Regression Confidence Intervals","text":"<pre><code>import pandas as pd\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression \nimport bootstrap\nN_POINTS = 50\nSLOPE = 3\nINTERCEPT = 2\nSIGMA = 5\ndf = pd.DataFrame({\n\"x\": np.random.uniform(0, 3, size=N_POINTS)\n})\ndf[\"y\"] = (\nINTERCEPT \n+ SLOPE * df[\"x\"] \n# Noise\n+ np.random.normal(loc=0, scale=SIGMA, size=N_POINTS)\n)\ndef bfunc(df: pd.DataFrame, model: LinearRegression) -&gt; pd.Series: \nmodel.fit(df[[\"x\"]], df[\"y\"])\nreturn pd.Series({\n\"intercept\": model.intercept_, \n\"slope\": model.coef_[0]\n})\nB = 5_000\nmodel = LinearRegression()\ndf_bootstrap = df.boot.get_samples(bfunc=bfunc, B=B, model=model)\n</code></pre> <p>which results in:</p> <pre><code>        intercept     slope\nsample                     \n0       -0.369922  2.985659\n1       -0.139439  3.312337\n2       -1.878551  3.981249\n3       -0.080539  2.888800\n4       -0.679095  4.191550\n</code></pre> <p></p>"},{"location":"examples/return-type/","title":"Return Type","text":"<p>The return type of <code>get_samples</code> is determined by the return type of the <code>bfunc</code> function.</p> <code>bfunc</code> return type <code>get_samples</code> return type index of <code>get_samples</code> <code>float</code> or <code>int</code> <code>pd.Series</code> sample number <code>pd.Series</code> <code>pd.DataFrame</code> sample number <code>pd.DataFrame</code> <code>pd.DataFrame</code> sample number and original index <pre><code>import pandas as pd\nimport numpy as np\nimport bootstrap\nn_points = 100\ndf = pd.DataFrame({\n\"a\": np.random.normal(size=n_points),\n\"b\": np.random.normal(size=n_points),\n\"group\": np.random.choice([\"A\", \"B\"], size=n_points)\n})\ndef float_return(df: pd.DataFrame, col: str) -&gt; float:\nreturn df[col].mean()\ndef series_return(df: pd.DataFrame) -&gt; pd.Series:\nreturn df.mean()\ndef df_return(df: pd.DataFrame) -&gt; pd.DataFrame:\nreturn df.groupby(\"group\").mean()\nseries = df.boot.get_samples(bfunc=float_return, B=5)\ndataframe = df.boot.get_samples(bfunc=series_return, B=5)\ndataframe_grouped = df.boot.get_samples(bfunc=df_return, B=5)\n</code></pre>"}]}